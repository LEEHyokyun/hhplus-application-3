가. Redis 적용 과정
- 인기상품의 정보를 조회하고 이에 대한 성능을 개선하기 위해 Redis를 왜 사용해야하는지 근본적으로 이해합니다.
- 조회라는 서비스가 대용량 트래픽으로 발생할 경우 DB에 가해지는 부하를 분산하기 위한 전략을 고민합니다.
- Redis를 활용하기 위해 테이블 구축 및 시나리오를 구성, 이를 바탕으로 구현합니다.


나. Redis를 활용하여 인기상품 조회를 진행합니다.
- 스케쥴러를 통해 3일동안 특정 간격으로 Ranking(통계) 테이블에 인기상품 정보를 누적하고, 이 정보를 Redis에도 동일하게 누적합니다.
- 최종적으로는 사용자가 조회해오는 인기상품정보는 Redis에서 최초 시작하며, 이에 대한 정보를 DB에서 가공하여 최종 전달합니다(?)
- 3일을 간격으로 00시에 인기상품 정보는 새롭게 초기화 및 누적되어야 합니다.
- 부족한 시간 관계 상 선착순 쿠폰의 동시성 보장과 순차처리는 추후 고민할 예정입니다.
- 나아가 학습범위를 확장해나가면서 Redis의 이해도를 심화할 계획입니다.

다. 도메인 및 책임(계층)을 설정합니다.
다-1. 스케쥴러 도메인 설정
- 스케쥴러 도메인은 별도로 설정하고, 컴포넌트(Bean)으로 등록을 하기 위해 main 도메인의 하위로 구성합니다.
- 각 도메인별로 사용하고자 하는 목적이 다를 수 있으므로, 도메인 하위 계층으로 구성합니다.
다-2. RedisTemplate을 조회 서비스 내에서 바로 적용(추후 개선)
- Redis 자료구조를 다루기 위해서는 JPA의 Persistence Layer와는 다른 양상으로 적용합니다.
- RedisTemplate이라는 필드객체를 주입받아 이곳에서 제공하는 기능을 사용하기에, Service 하위 계층 혹은 Service에 직접적인 의존관계를 설정하도록 구성합니다.
다-3. 주문도메인 : 통계테이블로의 인기상품정보 추출
- 기본적으로 매일 특정 간격으로 Ranking 정보를 추출하기 위해 스케쥴러를 활용해야 합니다.
- 원천테이블(Order)에서 주문정보를 바탕으로 Ranking 값을 계산하여 통계테이블로 저장하며, 이 과정은 Redis와 관련이 없는 별도의 과정입니다.
- 통계테이블의 정보를 동일하게 Redis 데이터로 이관하기 위한 작업도 스케쥴러로 하며, 일단 Ranking 정보 추출 시 그대로 누적하도록 동일한 트랜잭션으로 구성합니다(즉 통계테이블로 저장과 Redis 데이터로 저장하는 과정은 하나의 트랜잭션)
- 해당 스케쥴러는 주문도메인 하위에서 이루어지도록 합니다.
- 3일 이후에 인기상품 정보는 초기화됩니다.

라. 통합테스트 설계
- 각 분리된 도메인의 결합 서비스를 테스트한다는 과정으로 보았을때 통합테스트의 범주로 간주하는 것이 적합하다 생각하였습니다.

마. Redis를 통해 구조적 분산 전략을 사용하는 목적
- 인기상품조회를 DB에서만 이루어지는 것이 아닌 책임의 일부를 Redis와 함께 지도록 하여, DB의 부하와 부담을 경감할 수 있습니다.
- 기본적으로 트래픽이 DB에 집중되지 않고 Redis로 적절한 분산이 이루어지도록 할 수 있으므로, 트래픽 분산을 기대할 수 있습니다.
- 인기상품조회보다 선착순 쿠폰에서 동시성 제어와 순차성 보장, 원자성 보장이 단일 스레드에서 동시에 이루어질 수 있으므로 Redis를 통한 대용량 트래픽 제어 학습 효과를 더 기대할 수 있을 것 같습니다.
